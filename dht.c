//dht.c#include <stdio.h>#include <stdlib.h>#include <string.h>#include <math.h>#include "freertos/FreeRTOS.h"#include "freertos/task.h"#include "freertos/queue.h"#include "nvs.h"#include "rom/ets_sys.h"#include "driver/gpio.h"#include "esp_adc_cal.h"#include "dht.h"#include "functions.h"#include "iodev.h"#include "freertos/semphr.h"//Global variables from mainextern TaskHandle_t DHTHandle;extern int DHT_PIN;extern QueueHandle_t queue;extern SemaphoreHandle_t queueSemaphore;//Global function pointersvoid (*dht_open_ptr)() = &DHT_open;void (*dht_read_ptr)() = &DHT_read;void (*dht_ctl_ptr)() = &DHT_ctl;void (*dht_close_ptr)() = &DHT_close;//DHT11 sensor task (Temp and Humidity)void DHT_Task(void *pvParameter){  nvs_handle my_handle = NULL;	int DHT_Period = 4000;  char periodstring[25];  esp_err_t err = NULL;  TickType_t xLastWakeTime, finishtime;  TickType_t exectime, slacktime, utilization;  int fd;	//Initialize DHT sensor	fd = dopen("dht");  	//Initialize task period	nvsset(my_handle, "DHT_Period", "4000", err);  	while(1)	{		//Set start time for period		xLastWakeTime = xTaskGetTickCount();				dread(fd);		nvsget(my_handle, "DHT_Period", periodstring, err);		DHT_Period = atoi(periodstring);				//Capture the finish time for the task		finishtime = xTaskGetTickCount();				//Calculate execution time, slack time and utilization		exectime = finishtime - xLastWakeTime;		slacktime = DHT_Period - exectime;		utilization = exectime/(DHT_Period/portTICK_RATE_MS);		vTaskDelayUntil(&xLastWakeTime, DHT_Period / portTICK_RATE_MS);    }}//API functionsvoid DHT_open()    //Open and close APIs will operate per device not function{	nvs_handle my_handle = NULL;	esp_err_t err = NULL;    DHT_PIN = 23;    nvsset(my_handle,"DHT_Period","4000",err);    return;  }void DHT_read(){  char string[17];  char string2[17];  int counter = 0;  uint8_t bits[5] = {0,0,0,0,0};  //array storage for temp,hum  uint8_t byteCounter = 0;  uint8_t cnt = 7;  //getdata(array); //actually just redo the function here and use an array  //Send start signal from ESP32 to DHT device  gpio_set_direction(DHT_PIN, GPIO_MODE_OUTPUT);  gpio_set_level(DHT_PIN,0);  //vTaskDelay(36 / portTICK_RATE_MS);  ets_delay_us(22000);  gpio_set_level(DHT_PIN,1);  ets_delay_us(43);  gpio_set_direction(DHT_PIN, GPIO_MODE_INPUT);  //Wait for a response from the DHT11 device  //This requires waiting for 20-40 us  while (gpio_get_level(DHT_PIN)==1)  {      if(counter > 40)      {			//printf("ONE");            return;      }      counter = counter + 1;      ets_delay_us(1);  }  //Now that the DHT has pulled the line low,  //it will keep the line low for 80 us and then high for 80us  //check to see if it keeps low  counter = 0;  while(gpio_get_level(DHT_PIN)==0)  {  	if(counter > 80)  	{		printf("TWO");            return;  	}  	counter = counter + 1;  	ets_delay_us(1);  }  counter = 0;  while(gpio_get_level(DHT_PIN)==1)  {  	if(counter > 80)  	{			printf("THREE");            return;  	}  	counter = counter + 1;  	ets_delay_us(1);  }  // If no errors have occurred, it is time to read data  //output data from the DHT11 is 40 bits.  //Loop here until 40 bits have been read or a timeout occurs  for(int i = 0; i < 40; i++)  {      //int currentBit = 0;      //starts new data transmission with 50us low signal      counter = 0;      while(gpio_get_level(DHT_PIN)==0)  	  {  	  	if (counter > 55)  	  	{			printf("FOUR");            return;  	  	}  	  	counter = counter + 1;  	  	ets_delay_us(1);  	  }  	  //Now check to see if new data is a 0 or a 1      counter = 0;      while(gpio_get_level(DHT_PIN)==1)  	  {  	  	if (counter > 75)  	  	{			printf("FIVE");            return;  	  	}  	  	counter = counter + 1;  	  	ets_delay_us(1);  	  }  	  //add the current reading to the output data  	  //since all bits where set to 0 at the start of the loop, only looking for 1s  	  //look for when count is greater than 40 - this allows for some margin of error  	  if (counter > 40)  	  {  	  	bits[byteCounter] |= (1 << cnt);  	  }  	  //here are conditionals that work with the bit counters  	  if (cnt == 0)  	  {  	  	cnt = 7;  	  	byteCounter = byteCounter +1;  	  }else{  	  	cnt = cnt -1;  	  }  }  float humidity = bits[0];  float temperature = bits[2];  float Ftemperature = temperature * 1.8 + 32;  sprintf(string,"temp,%3.2f,",Ftemperature);  	//Take a reading and place in queue 	if (xSemaphoreTake(queueSemaphore, 0))	{		if (uxQueueSpacesAvailable(queue) > 0) //Only if space available			xQueueSend(queue, &string, 0);		xSemaphoreGive( queueSemaphore );	}  sprintf(string2,"humid,%3.2f,",humidity);  	//Take a reading and place in queue 	if (xSemaphoreTake(queueSemaphore, 0))	{		//printf("\nHumid: %f\n", humidity);		if (uxQueueSpacesAvailable(queue) > 0) //Only if space available			xQueueSend(queue, &string2, 0);		xSemaphoreGive( queueSemaphore );	}  return;}void DHT_close(){	//Deletes particle task, freeing its memor	vTaskDelete(DHTHandle);	return;}void DHT_ctl(){  nvs_handle my_handle = NULL;	char string[50];	esp_err_t err = NULL;	//Prompt user for new task period	printf("\nPlease enter a new period in ms:\n");	getstring(string, 50);	//Sets in NVS	nvsset(my_handle, "DHTPeriod", string, err);	return;}